#pragma once

namespace UAFML
{

//class af::array;
class INetworkLayer
{
public:

	INetworkLayer() : _size(0,0,0,0) {}
	INetworkLayer(const af::dim4 &size) : _size(size) {}
	virtual ~INetworkLayer() {}

	// Accessors & Mutators
	virtual const af::dim4& GetLayerSize() const { return _size;	}
	virtual void SetLayerSize(const af::dim4 &size) { _size = size; }

	// Propagation Functions
	/*
		paramters:	array	values [in/out] takes in the array of values from the previous layer
								and generates the new values for the next layer.
					array	weights [in] the theta values to use with this layer.
		return:		bool	indicator of whether propagation was successfully completed.
	*/
	virtual bool ForwardPropagate(af::array &values, const af::array &weights) = 0;

	/*
		paramters:	array	values [in/out] takes in the array of error values from the following
								layer and generates the new values for the preceding layer.
					array	weights [in] the theta values that were used with this layer.
		return:		array	the gradient for this layer's used theta values.
								errors will generate an empty array.
	*/
	virtual af::array BackPropagate(af::array &error, const af::array &weights) = 0;

	// Output Evaluation Functions
	/*
		paramters:	array	output [in] the array of values generated by forward propagation.
					array	truth [in] the expected values for this training set.
		return:		double	the calculated cost for this set of weights against this training set.
	*/
	virtual double CalculateCost(const af::array &output, const af::array &truth) = 0;

	/*
		paramters:	array	output [in/out] takes in the array of values generated by forward
								propagation and generates the error values to propagate backwards
								from this layer.
					array	truth [in] the expected values for this training set.
					array	weights [in] the theta values that were used with this layer.
		return:		array	the gradient for this layer's used theta values.
								errors or layers with no weights will generate an empty array.
	*/
	virtual af::array CalculateError(af::array &values, const af::array &truth, const af::array &weights) = 0;

protected:
	af::dim4 _size;
};

}
